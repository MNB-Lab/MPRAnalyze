---
title: "MPRAnalyze Tutorial"
author: "David S. Fischer"
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteEncoding{UTF-8}
---

<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{MPRAnalyze Vignette}
-->

```{r options, cache=FALSE, include=FALSE, results='hide', message=FALSE, warning=FALSE}

knitr::opts_chunk$set(fig.align="center", 
                      cache=FALSE,
                      error=FALSE,
                      fig.width=6,fig.height=6,
                      autodep=TRUE,
                      out.width="600px", 
                      out.height="600px",
                      message=FALSE,
                      warning=FALSE,
                      results="hide", 
                      echo=TRUE, 
                      eval=TRUE)

options(getClass.msg=FALSE)
```

# Introduction

MPRAnalyze is an analysis framework for MPRA data that aims at translating the main scientific questions arising in the context of MPRA data into statistical problems. Such questions include variations of ranking enhancers by caused expression magnitude 
and testing for differential enhancer activity between conditions. Thereby, MPRAnalyze allows the user to answer those questions as part of a likelihood-based framework based on p-values and expression strength scores.

MPRAnalyze requires a matrix of transcript/RNA counts
and a matrix of plasmid/DNA counts.
Both matrices must contain integers or NA only and have the same shape and dimension names.
Secondly, sample metadata and an estimation scheme ID must be provided.
The user should consider the minimal parameter set for the wrapper function runMPRAnalyze:

* matRNACounts Count matrix RNA (enhancers x samples). No normalisation or transformations, the entries must be integers!
* matDNACounts Count matrix DNA (enhancers x samples). No normalisation or transformations, the entries must be integers!
* dfAnnotation Data frame with sample meta data
* strModel Model name. {"lnDNAlnRNA", "gammaDNApoisRNA", "gammaDNApoisRNA_coordascent"} and
boolPreFitCtrlDNA.
Model and estimation scheme to be used. Currently, we suggest the use of 
strModel=lnDNAlnRNA,boolPreFitCtrlDNA=FALSE for DNA point estimator-based models, 
strModel=gammaDNApoisRNA,boolPreFitCtrlDNA=FALSE for marginalisation-based models with few or no control enhancers (<10) and
strModel=gammaDNApoisRNA,boolPreFitCtrlDNA=TRUE for marginalisation-based models with many control enhancers.
strModel=gammaDNApoisRNA_coordascent,boolPreFitCtrlDNA=FALSE is an alternative if many control enhancers are used.

lnDNAlnRNA: DNA point estimators are pre-estimated based on a lognormal model.
The expression model is then fit based on a negative binomial likelihood of the RNA counts.
gammaDNApoisRNA: DNA and expression model are co-estimated, exloiting a closed
form marginalisation. The DNA counts are modeled with a beta distribution
and the RNA counts with a poisson distribution. If boolPreFitCtrlDNA==TRUE,
the estimation is conditioned on a pre-fit model
gammaDNApoisRNA_coordascent: As gammaDNApoisRNA but can be used to estimate
models with many control enhancers. The problem is broken up into iterative
DNA and expression model estimation until it converges to a local optimum of
the likelihood function.

Additionally, one can provide:

* vecCtrlIDs Vector of strings: Rownames of sequences which are scrambled/control enhancers in count matrices.
* strModelFull Currently not applicable.
* strModelRed Currently not applicable.
* vecModelFacRNAFull (vector of strings lenght number of factors in FULL expression model) [Default NULL] The model factors (columns in dfAnnotation) which are to be used in the FULL expression model. The expression model will have batch adjustment for these factors.
* vecModelFacRNAFullCtrl (vector of strings lenght number of additional factors in FULL expression model for control enhancers) [Default NULL] The model factors (columns in dfAnnotation) which are to be used in the FULL control expression model. The expression model will have batch adjustment for these factors.
* vecModelFacRNARed (vector of strings lenght number of factors in REDUCED expression model) [Default NULL] The model factors (columns in dfAnnotation) which are to be used in the REDUCED expression model. The expression model will have batch adjustment for these factors.
* vecModelFacRNARedCtrl (vector of strings lenght number of additional factors in REDUCED expression model for control enhancers) [Default NULL] The model factors (columns in dfAnnotation) which are to be used in the REDUCED control expression model. The expression model will have batch adjustment for these factors.
* vecModelFacDNA (vector of strings lenght number of factors in DNA model) [Default NULL] The model factors (columns in dfAnnotation) which are to be used  in the DNA model. The DNA model will have batch adjustment for these factors.
* scaNProc Number of processes to use during parallelisation.
* vecDispersionsExternal Currently not applicable.
* vecRNADepthExternal Externally supplied RNA sample sequencing depth factors.
* vecDNADepthExternal Externally supplied DNA sample sequencing depth factors.
* boolVerbose Control output of package.


# Without scrambled sequences
## Compare the strength of enhancers 
This comparison is done in one condition.
Either, the strength is directly compared based on the model parameter (no testing)
or all enhancers are compared against a reference (e.g. the WT) enhancer.
The testing scenario corresponds to the scrambled scenario if in which the set of scrambled enhancers is the WT enhancer.
The parameter which can be compared directly is the baseline transcription strength.
This model is fit as an MLE and the the ranked baseline transcription strength are given as an output.

## Test the effect of an condition
A hypothesis test is conducted to test whether expression varies significantly (= is non-constant) as a function of the fiven conditions(s).

```{r heatmap, results='markdown'}
# source("..path../MPRAnalyze/R/main_MPRAnalyze.R")
# Produce example data: lognormal distributed DNA and poisson distributed RNA
source("~/gitDevelopment/MPRAnalyze/R/main_MPRAnalyze.R")
vecSampleEffect <- rep(rnorm(n = 25, mean = 1, sd = 0.1), 4) # Could be barcode effects
vecSampleEffect[vecSampleEffect < 0.2] <- 0.2 # Threshold
vecMuDNA <- sample(x=100, size=20)
matDNACounts <- do.call(rbind, lapply(vecMuDNA, function(mu) {
    round(rlnorm(n=scaNSamples, meanlog = log(mu), sdlog = 1)*vecSampleEffect)
}))
matDNACounts[matDNACounts <= 1] <- 1
rownames(matDNACounts) <- c(
    paste0("Seq_", 1:20)
)
colnames(matDNACounts) <- paste0("S", 1:scaNSamples)
vecExprRates <- seq(0.5,2, length.out = 20)
matCondEffect <- matrix(1, nrow=20, ncol=100)
vecCondEffect <- c(rep(1,50), rep(2,50))
vecidxAfftectedEnhancers <- c(1,2,5,10)
for(i in vecidxAfftectedEnhancers) {
    matCondEffect[i,] <- vecCondEffect
}
matRNACounts <- do.call(rbind, lapply(1:20, function(i) {
    sapply(matDNACounts[i,]*matCondEffect[i,], function(x) 
        round(rpois(n=1, lambda = x*vecExprRates[i])) )
}))
rownames(matRNACounts) <- rownames(matDNACounts)
colnames(matRNACounts) <- colnames(matDNACounts)
dfAnnotation <- data.frame(
    sample=rownames(matRNACounts),
    time=c(rep("start", 50),rep("end", 50)),
    barcode=rep(paste0("BC",1:25),4),
    stringsAsFactors = FALSE
)
# Run MPRAnalyze
objMPRA <- runMPRAnalyze(
  matRNACounts=matRNACounts, 
  matDNACounts=matDNACounts, 
  dfAnnotation=dfAnnotation,
  vecCtrlIDs=NULL,
  vecModelFacRNAFull=c("1","time"),
  vecModelFacRNAFullCtrl=NULL,
  vecModelFacRNARed=c("1"),
  vecModelFacRNARedCtrl=NULL,
  vecModelFacDNA=c("barcode", "time"),
  strModel="gammaDNApoisRNA",#"pointlnDNAnbRNA"
  boolPreFitCtrlDNA=FALSE,
  scaNProc=1, 
  boolVerbose=TRUE )
print(objMPRA$dfMPRAnalyzeResults[order(objMPRA$dfMPRAnalyzeResults$p),])
```

# With scrambled sequences
## Test the strength of enhancers


## Test the effect of an condition
For example: Test the time dependency of expression with control enhancers.

A control time course of garbage sequences can be handled as case-control differential expression analysis where control
is fit to all garbage sequence time courses (i.e. control is the mean garbage signal).
Again, assume a condition to be tested $c1$, such as time,
and a confounding condition $c2$.
$\Omega$ is the set of garbage enhancers.
The null model $H0$ has unconstrained DNA models and a constraint on the expression model:
The expression model is the same for the garbage sequences and the enhancer of interest with respect to the conditions of interest (here, $c1$ or time).

Note that the DNA model is parameterised per enhancer, including the scrambled ones, while the size of the expression model does not depend on the number of scrambled enhancers.
With about 100 parameters for the DNA model per enhancer and 200 scrambles, the total model if roughly 20,000 dimensional which is not numerically feasible.
One option could be to reduce the DNA model size by reducing the barcode model to a GC-content model.
Alternatively and currently implemented is a batch-wise coordinate ascent in which iteratively, 1. DNA models are estimated in parallel conditioned on the expression model and 2. the expression model estimated conditioned on all DNA models.
This batch-wise estimation is guaranteed to yield a local minimum of the likelihood function and breaks arbitrarily large data sets up into optimisation problems small enough to be solved with BFGS.

```{r heatmap, results='markdown'}
# source("..path../MPRAnalyze/R/main_MPRAnalyze.R")
# Produce example data: lognormal distributed DNA and poisson distributed RNA
source("~/gitDevelopment/MPRAnalyze/R/main_MPRAnalyze.R")
vecSampleEffect <- rep(rnorm(n = 25, mean = 1, sd = 0.1), 4) # Could be barcode effects
vecSampleEffect[vecSampleEffect < 0.2] <- 0.2 # Threshold
vecMuDNA <- sample(x=100, size=20)
matDNACounts <- do.call(rbind, lapply(vecMuDNA, function(mu) {
    round(rlnorm(n=scaNSamples, meanlog = log(mu), sdlog = 1)*vecSampleEffect)
}))
matDNACounts[matDNACounts <= 1] <- 1
rownames(matDNACounts) <- c(
    paste0("Seq_", 1:10), paste0("Ctrl_", 1:10)
)
colnames(matDNACounts) <- paste0("S", 1:scaNSamples)
vecExprRates <- c(rep(0.5,10), rep(1.5,10))
matCondEffect <- matrix(1, nrow=20, ncol=100)
vecCondEffect <- c(rep(1,50), rep(2,50))
vecidxAfftectedEnhancers <- c(1,2,5,10)
for(i in vecidxAfftectedEnhancers) {
    matCondEffect[i,] <- vecCondEffect
}
matRNACounts <- do.call(rbind, lapply(1:20, function(i) {
    sapply(matDNACounts[i,]*matCondEffect[i,], function(x) 
        round(rpois(n=1, lambda = x*vecExprRates[i])) )
}))
rownames(matRNACounts) <- rownames(matDNACounts)
colnames(matRNACounts) <- colnames(matDNACounts)
dfAnnotation <- data.frame(
    sample=rownames(matRNACounts),
    time=c(rep("start", 50),rep("end", 50)),
    barcode=rep(paste0("BC",1:25),4),
    stringsAsFactors = FALSE
)
# Run MPRAnalyze
objMPRA <- runMPRAnalyze(
  matRNACounts=matRNACounts, 
  matDNACounts=matDNACounts, 
  dfAnnotation=dfAnnotation,
  vecCtrlIDs=paste0("Ctrl_", 1:10),
  vecModelFacRNAFull=c("1","time"),
  vecModelFacRNAFullCtrl=c("1","time"),
  vecModelFacRNARed=c("1","time"),
  vecModelFacRNARedCtrl=c("1"),
  vecModelFacDNA=c("barcode", "time"),
  strModel="gammaDNApoisRNA",#"pointlnDNAnbRNA"
  boolPreFitCtrlDNA=TRUE,
  scaNProc=1, 
  boolVerbose=TRUE )
print(objMPRA$dfMPRAnalyzeResults[order(objMPRA$dfMPRAnalyzeResults$padj),])
```

# Session information

```{r session}
sessionInfo()
```